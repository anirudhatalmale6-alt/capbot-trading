from __future__ import annotations
from dataclasses import dataclass
from typing import Any, Dict, Optional

import pandas as pd
import numpy as np


@dataclass
class Signal:
    direction: str  # "BUY" / "SELL"
    meta: Dict[str, Any]


def _rma(x: pd.Series, n: int) -> pd.Series:
    # Wilder RMA ~= EMA(alpha=1/n, adjust=False)
    return x.ewm(alpha=1.0 / float(n), adjust=False).mean()


def _rsi_wilder(close: pd.Series, n: int) -> pd.Series:
    delta = close.diff()
    up = delta.clip(lower=0.0)
    down = (-delta).clip(lower=0.0)
    avg_up = _rma(up, n)
    avg_down = _rma(down, n)
    rs = avg_up / avg_down.replace(0, np.nan)
    rsi = 100.0 - (100.0 / (1.0 + rs))
    return rsi


def _atr_wilder(df: pd.DataFrame, n: int) -> pd.Series:
    high = df["high"]
    low = df["low"]
    close = df["close"]
    prev_close = close.shift(1)
    tr = pd.concat(
        [
            (high - low),
            (high - prev_close).abs(),
            (low - prev_close).abs(),
        ],
        axis=1,
    ).max(axis=1)
    return _rma(tr, n)


def _vwap_daily_berlin(df: pd.DataFrame, tz: str) -> pd.Series:
    # Reset 00:00 Berlin
    idx_local = df.index.tz_convert(tz)
    day = idx_local.date

    tp = (df["high"] + df["low"] + df["close"]) / 3.0
    v = df["volume"].astype(float)

    pv = tp * v
    cum_pv = pv.groupby(day).cumsum()
    cum_v = v.groupby(day).cumsum()

    vwap = cum_pv / cum_v.replace(0, np.nan)
    return vwap


class DE40VWAPK020:
    """
    Estrategia DE40/GER40 5m — VWAP diario + filtro distancia VWAP (k=0.20)
    Señal con vela cerrada; entrada en open de la vela siguiente.
    """

    def enrich(self, df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
        out = df.copy()

        vol_window = int(params.get("VOL_WINDOW", 20))
        rsi_len = int(params.get("RSI_LEN", 14))
        atr_len = int(params.get("ATR_LEN", 14))
        tz = str(params.get("VWAP_TZ", "Europe/Berlin"))

        # Body ratio
        rng = (out["high"] - out["low"]).replace(0, np.nan)
        out["body_ratio"] = (out["close"] - out["open"]).abs() / rng
        out["body_ratio"] = out["body_ratio"].fillna(0.0)

        # Vol rel
        out["vol_sma"] = out["volume"].rolling(vol_window).mean()
        out["vol_rel"] = out["volume"] / out["vol_sma"].replace(0, np.nan)

        # Prev3 bears/bulls
        is_bear = (out["close"] < out["open"]).astype(int)
        is_bull = (out["close"] > out["open"]).astype(int)
        out["bear_prev3"] = is_bear.shift(1).rolling(3).sum()
        out["bull_prev3"] = is_bull.shift(1).rolling(3).sum()

        # RSI / ATR
        out["rsi14"] = _rsi_wilder(out["close"], rsi_len)
        out["atr14"] = _atr_wilder(out, atr_len)

        # VWAP
        out["vwap"] = _vwap_daily_berlin(out, tz)

        return out

    def signal_on_bar_close(self, df: pd.DataFrame, params: Dict[str, Any]) -> Optional[Signal]:
        if df is None or len(df) < 50:
            return None

        # signal_bar = última cerrada
        i = -2
        row = df.iloc[i]
        ts_utc = df.index[i]  # tz-aware UTC en el motor
        tz = str(params.get("VWAP_TZ", "Europe/Berlin"))
        ts_local = ts_utc.tz_convert(tz)

        # Parámetros
        BODY_MIN = float(params.get("BODY_MIN", 0.70))
        VOL_REL_MIN = float(params.get("VOL_REL_MIN", 0.70))
        RSI_LONG_MAX = float(params.get("RSI_LONG_MAX", 75))
        RSI_SHORT_MIN = float(params.get("RSI_SHORT_MIN", 40))
        BEAR_PREV3_LONG = int(params.get("BEAR_PREV3_LONG", 2))
        BULL_PREV3_SHORT = int(params.get("BULL_PREV3_SHORT", 2))
        SL_ATR = float(params.get("SL_ATR", 1.0))
        VWAP_DISTANCE_K = float(params.get("VWAP_DISTANCE_K", 0.20))

        # Horarios (Berlin) + jueves UTC
        disable_thursday_utc = bool(params.get("DISABLE_THURSDAY_UTC", True))
        no_trade_hours = set(params.get("NO_TRADE_HOURS_BERLIN", [9, 14, 15]))
        rth_start = str(params.get("RTH_START", "09:30"))
        rth_end = str(params.get("RTH_END", "17:30"))

        sh, sm = map(int, rth_start.split(":"))
        eh, em = map(int, rth_end.split(":"))
        start_ok = (ts_local.hour > sh) or (ts_local.hour == sh and ts_local.minute >= sm)
        end_ok = (ts_local.hour < eh) or (ts_local.hour == eh and ts_local.minute <= em)
        in_rth = start_ok and end_ok

        if disable_thursday_utc and ts_utc.weekday() == 3:
            return None
        if not in_rth:
            return None
        if ts_local.hour in no_trade_hours:
            return None

        # Validaciones
        need_cols = ["body_ratio", "vol_rel", "rsi14", "atr14", "vwap", "bear_prev3", "bull_prev3"]
        for c in need_cols:
            if c not in df.columns:
                return None
            v = row.get(c)
            if v is None or (isinstance(v, float) and (np.isnan(v) or np.isinf(v))):
                return None

        body_ratio = float(row["body_ratio"])
        vol_rel = float(row["vol_rel"])
        rsi = float(row["rsi14"])
        atr = float(row["atr14"])
        vwap = float(row["vwap"])
        close = float(row["close"])
        open_ = float(row["open"])
        bear_prev3 = float(row["bear_prev3"])
        bull_prev3 = float(row["bull_prev3"])

        if body_ratio < BODY_MIN:
            return None
        if vol_rel < VOL_REL_MIN:
            return None

        # Filtro distancia VWAP: abs(close-vwap) >= k * ATR
        if atr <= 0:
            return None
        if abs(close - vwap) < (VWAP_DISTANCE_K * (SL_ATR * atr)):
            return None

        # Señales
        # LONG
        if (close > vwap) and (bear_prev3 >= BEAR_PREV3_LONG) and (rsi <= RSI_LONG_MAX) and (close > open_):
            return Signal(direction="BUY", meta={
                "ts_signal_utc": ts_utc.isoformat(),
                "ts_signal_local": ts_local.isoformat(),
                "close": close, "vwap": vwap, "rsi": rsi, "atr": atr,
                "body_ratio": body_ratio, "vol_rel": vol_rel,
                "bear_prev3": bear_prev3,
            })

        # SHORT
        if (close < vwap) and (bull_prev3 >= BULL_PREV3_SHORT) and (rsi >= RSI_SHORT_MIN) and (close < open_):
            return Signal(direction="SELL", meta={
                "ts_signal_utc": ts_utc.isoformat(),
                "ts_signal_local": ts_local.isoformat(),
                "close": close, "vwap": vwap, "rsi": rsi, "atr": atr,
                "body_ratio": body_ratio, "vol_rel": vol_rel,
                "bull_prev3": bull_prev3,
            })

        return None

    def initial_risk(self, entry_price: float, atr_v: float, sig: Signal, params: Dict[str, Any]) -> Dict[str, Any]:
        SL_ATR = float(params.get("SL_ATR", 1.0))
        TP_ATR = float(params.get("TP_ATR", 3.0))

        r_points = SL_ATR * float(atr_v)
        if sig.direction == "BUY":
            sl = float(entry_price) - r_points
            tp = float(entry_price) + (TP_ATR * float(atr_v))
        else:
            sl = float(entry_price) + r_points
            tp = float(entry_price) - (TP_ATR * float(atr_v))

        return {
            "r_points": float(r_points),
            "sl_local": float(sl),
            "tp_local": float(tp),
            "tp_r_multiple": float(TP_ATR / max(SL_ATR, 1e-9)),
        }
