from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional

import numpy as np
import pandas as pd



def _get_ts_utc(df: pd.DataFrame, i: int) -> pd.Timestamp:
    """
    Devuelve timestamp tz-aware en UTC para la vela i.
    Soporta:
      - df.index DatetimeIndex
      - df["time"] columna (str/int) parseable
    """
    if isinstance(df.index, pd.DatetimeIndex):
        ts = df.index[i]
        if df.index.tz is None:
            return ts.tz_localize("UTC")
        return ts.tz_convert("UTC")

    if "time" in df.columns:
        ts = pd.to_datetime(df["time"].iloc[i], utc=True, errors="coerce")
        if ts is pd.NaT:
            raise ValueError("DE40: no pude parsear df['time'] a datetime")
        return ts

    raise ValueError("DE40: requiere df.index DatetimeIndex o columna 'time'")

# Importa helpers existentes en el mismo archivo original (si estaban ahí).
# Si en tu archivo original estaban definidas estas funcs abajo, déjalas tal cual.
# Aquí asumo que ya existen: _rsi_wilder, _atr_wilder, _vwap_daily_berlin.
from capbot.strategies.vwap_pullback_rsi import Signal  # mismo dataclass usado en tu repo

class DE40VWAPK020:
    """
    Estrategia DE40/GER40 5m — VWAP diario + filtro distancia VWAP (k=0.20)
    Señal con vela cerrada; entrada en open de la vela siguiente (lo hace el engine).
    """

    def enrich(self, df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
        out = df.copy()

        vol_window = int(params.get("VOL_WINDOW", 20))

        # Soportar ambos nombres: RSI_LEN o RSI_PERIOD
        rsi_len = int(params.get("RSI_LEN", params.get("RSI_PERIOD", 14)))
        atr_len = int(params.get("ATR_LEN", params.get("ATR_PERIOD", 14)))

        tz = str(params.get("VWAP_TZ", "Europe/Berlin"))

        # Body ratio
        rng = (out["high"] - out["low"]).replace(0, np.nan)
        out["body_ratio"] = (out["close"] - out["open"]).abs() / rng
        out["body_ratio"] = out["body_ratio"].fillna(0.0)

        # Vol rel
        out["vol_sma"] = out["volume"].rolling(vol_window).mean()
        out["vol_rel"] = out["volume"] / out["vol_sma"].replace(0, np.nan)

        # Prev3 bears/bulls (shift(1).rolling(3).sum())
        is_bear = (out["close"] < out["open"]).astype(int)
        is_bull = (out["close"] > out["open"]).astype(int)
        out["bear_prev3"] = is_bear.shift(1).rolling(3).sum()
        out["bull_prev3"] = is_bull.shift(1).rolling(3).sum()

        # RSI / ATR Wilder
        from capbot.strategies.vwap_pullback_rsi import rsi_wilder as _rsi_wilder
        from capbot.strategies.vwap_pullback_rsi import atr_wilder as _atr_wilder
        from capbot.strategies.vwap_pullback_rsi import vwap_daily_berlin as _vwap_daily_berlin

        out["rsi14"] = _rsi_wilder(out["close"], rsi_len)
        out["atr14"] = _atr_wilder(out, atr_len)

        # VWAP diario reset 00:00 Berlin con typical price
        out["vwap"] = _vwap_daily_berlin(out, tz)

        return out

    def signal_on_bar_close(self, df: pd.DataFrame, params: Dict[str, Any]) -> Optional[Signal]:

        import pandas as pd

        import numpy as np


        debug = bool(params.get("DEBUG_CHECKS", False))


        def _ts_from_df(i: int) -> pd.Timestamp:

            # Preferir DatetimeIndex; fallback a columna 'time' si existe; fallback a pd.to_datetime del índice

            if isinstance(df.index, pd.DatetimeIndex):

                ts = df.index[i]

                ts = ts if isinstance(ts, pd.Timestamp) else pd.to_datetime(ts, utc=True, errors="coerce")

                if ts is not None and getattr(ts, "tz", None) is None:

                    ts = ts.tz_localize("UTC")

                elif ts is not None:

                    ts = ts.tz_convert("UTC")

                return ts

            if "time" in df.columns:

                ts = pd.to_datetime(df["time"].iloc[i], utc=True, errors="coerce")

                return ts

            # último recurso: intentar convertir el índice numérico

            ts_raw = df.index[i]

            try:

                ts = pd.to_datetime(ts_raw, utc=True, errors="coerce")

                return ts

            except Exception:

                return pd.Timestamp.utcnow().tz_localize("UTC")


        def _check_line(ts_utc: pd.Timestamp, ts_local: pd.Timestamp, row, flags: dict, note: str = ""):

            if not debug:

                return

            def fmt(v, nd=3):

                try:

                    if v is None or (isinstance(v, float) and (np.isnan(v) or np.isinf(v))):

                        return "nan"

                    return f"{float(v):.{nd}f}"

                except Exception:

                    return str(v)

            body = row.get("body_ratio")

            volr = row.get("vol_rel")

            rsi  = row.get("rsi14")

            atr  = row.get("atr14")

            vwap = row.get("vwap")

            close_px = row.get("close")


            f = lambda k: ("✅" if flags.get(k) else "❌")

            print(

                f"[{ts_utc.isoformat()}] CHECK "

                f"t_local={ts_local.strftime('%Y-%m-%d %H:%M')} "

                f"body={fmt(body)} vol_rel={fmt(volr)} rsi={fmt(rsi,1)} atr={fmt(atr,2)} "

                f"vwap={fmt(vwap,1)} close={fmt(close_px,1)} "

                f"RTH={f('in_rth')} THU={f('thu_ok')} NTH={f('nth_ok')} "

                + (f"NOTE={note}" if note else "")

            )


        if df is None or len(df) < 50:

            return None


        # vela cerrada

        i = -2

        row = df.iloc[i]


        tz = str(params.get("VWAP_TZ", "Europe/Berlin"))

        ts_utc = _ts_from_df(i)

        if ts_utc is None or pd.isna(ts_utc):

            ts_utc = pd.Timestamp.utcnow().tz_localize("UTC")

        ts_local = ts_utc.tz_convert(tz)


        # Parámetros

        BODY_MIN = float(params.get("BODY_MIN", 0.70))

        VOL_REL_MIN = float(params.get("VOL_REL_MIN", 0.70))

        RSI_LONG_MAX = float(params.get("RSI_LONG_MAX", 75))

        RSI_SHORT_MIN = float(params.get("RSI_SHORT_MIN", 40))

        BEAR_PREV3_LONG = int(params.get("BEAR_PREV3_LONG", 2))

        BULL_PREV3_SHORT = int(params.get("BULL_PREV3_SHORT", 2))

        VWAP_DISTANCE_K = float(params.get("VWAP_DISTANCE_K", 0.20))


        disable_thursday_utc = bool(params.get("DISABLE_THURSDAY_UTC", True))

        no_trade_hours = set(params.get("NO_TRADE_HOURS_BERLIN", [9, 14, 15]))

        rth_start = str(params.get("RTH_START", "09:30"))

        rth_end = str(params.get("RTH_END", "17:30"))


        sh, sm = map(int, rth_start.split(":"))

        eh, em = map(int, rth_end.split(":"))

        start_ok = (ts_local.hour > sh) or (ts_local.hour == sh and ts_local.minute >= sm)

        end_ok = (ts_local.hour < eh) or (ts_local.hour == eh and ts_local.minute <= em)

        in_rth = start_ok and end_ok


        thu_ok = not (disable_thursday_utc and ts_utc.weekday() == 3)

        nth_ok = (ts_local.hour not in no_trade_hours)


        flags = {"in_rth": in_rth, "thu_ok": thu_ok, "nth_ok": nth_ok}


        # Log 1 vez por vela cerrada (guard por timestamp local/utc)

        # (si te spamea por restarts, al menos verás el mismo ts repetido)

        if not thu_ok:

            _check_line(ts_utc, ts_local, row, flags, note="blocked_thursday_utc")

            return None

        if not in_rth:

            _check_line(ts_utc, ts_local, row, flags, note="outside_rth")

            return None

        if not nth_ok:

            _check_line(ts_utc, ts_local, row, flags, note=f"no_trade_hour={ts_local.hour}")

            return None


        # Validaciones de columnas

        need_cols = ["body_ratio", "vol_rel", "rsi14", "atr14", "vwap", "bear_prev3", "bull_prev3"]

        for c in need_cols:

            if c not in df.columns:

                _check_line(ts_utc, ts_local, row, flags, note=f"missing_col={c}")

                return None

            v = row.get(c)

            if v is None or (isinstance(v, float) and (np.isnan(v) or np.isinf(v))):

                _check_line(ts_utc, ts_local, row, flags, note=f"bad_val_col={c}")

                return None


        body_ratio = float(row["body_ratio"])

        vol_rel = float(row["vol_rel"])

        rsi = float(row["rsi14"])

        atr = float(row["atr14"])

        vwap = float(row["vwap"])

        close = float(row["close"])

        open_ = float(row["open"])

        bear_prev3 = float(row["bear_prev3"])

        bull_prev3 = float(row["bull_prev3"])


        # checks base (como en tu screenshot)

        if body_ratio < BODY_MIN:

            _check_line(ts_utc, ts_local, row, flags, note=f"body_ratio_fail {body_ratio:.3f}<{BODY_MIN}")

            return None

        if vol_rel < VOL_REL_MIN:

            _check_line(ts_utc, ts_local, row, flags, note=f"vol_rel_fail {vol_rel:.3f}<{VOL_REL_MIN}")

            return None


        # GATE distancia a VWAP (k * ATR)

        if abs(close - vwap) < (VWAP_DISTANCE_K * atr):

            _check_line(ts_utc, ts_local, row, flags, note="vwap_distance_block")

            return None


        # Lógica señal (resumen; respetamos tu lógica original típica)

        # BUY: vela alcista, bear_prev3>=2, rsi<=RSI_LONG_MAX, close>vwap

        # SELL: vela bajista, bull_prev3>=2, rsi>=RSI_SHORT_MIN, close<vwap

        is_bull = close > open_

        is_bear = close < open_


        buy_ok = bool(is_bull and bear_prev3 >= BEAR_PREV3_LONG and rsi <= RSI_LONG_MAX and close > vwap)

        sell_ok = bool(is_bear and bull_prev3 >= BULL_PREV3_SHORT and rsi >= RSI_SHORT_MIN and close < vwap)


        if not buy_ok and not sell_ok:

            _check_line(ts_utc, ts_local, row, flags, note="no_signal_conditions")

            return None


        direction = "BUY" if buy_ok else "SELL"

        _check_line(ts_utc, ts_local, row, flags, note=f"SIGNAL={direction}")

        return Signal(direction=direction, meta={"ts": ts_utc.isoformat()})

    def initial_risk(self, entry_price: float, atr_v: float, sig: Signal, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        EXACTO spec:
          R_pts = SL_ATR * ATR14(signal_bar)
          Long: SL = entry - 1R ; TP = entry + TP_R_MULTIPLE*R
          Short: SL = entry + 1R ; TP = entry - TP_R_MULTIPLE*R
        """
        SL_ATR = float(params.get("SL_ATR", 1.0))
        TP_R_MULTIPLE = float(params.get("TP_R_MULTIPLE", 3.0))

        r_points = SL_ATR * float(atr_v)

        if sig.direction == "BUY":
            sl = float(entry_price) - r_points
            tp = float(entry_price) + (TP_R_MULTIPLE * r_points)
        else:
            sl = float(entry_price) + r_points
            tp = float(entry_price) - (TP_R_MULTIPLE * r_points)

        return {
            "r_points": float(r_points),
            "sl_local": float(sl),
            "tp_local": float(tp),
            "tp_r_multiple": float(TP_R_MULTIPLE),
        }
