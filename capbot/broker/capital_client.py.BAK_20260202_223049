import json
import os
import time
from dataclasses import dataclass
from typing import Any, Dict, Optional, Tuple

import requests


# ----------------------------
# Types / errors
# ----------------------------

@dataclass
class Session:
    base: str
    cst: str
    xst: str


class CapitalConfigError(RuntimeError):
    pass


class CapitalAuthError(RuntimeError):
    pass


# ----------------------------
# Helpers
# ----------------------------

def base_url() -> str:
    env = os.environ.get("CAPITAL_ENV", "demo").lower().strip()
    return "https://demo-api-capital.backend-capital.com" if env == "demo" else "https://api-capital.backend-capital.com"


def _get_env_required() -> Tuple[str, str, str]:
    """
    Return (api_key, identifier, password) or raise CapitalConfigError with a clear message.
    """
    missing = []
    api_key = os.environ.get("CAPITAL_API_KEY")
    ident = os.environ.get("CAPITAL_IDENTIFIER")
    pwd = os.environ.get("CAPITAL_API_PASSWORD")

    if not api_key: missing.append("CAPITAL_API_KEY")
    if not ident: missing.append("CAPITAL_IDENTIFIER")
    if not pwd: missing.append("CAPITAL_API_PASSWORD")

    if missing:
        raise CapitalConfigError("Missing required env vars: " + ", ".join(missing))

    return api_key, ident, pwd


def _headers(api_key: str, cst: str, xst: str) -> Dict[str, str]:
    return {
        "X-CAP-API-KEY": api_key,
        "CST": cst,
        "X-SECURITY-TOKEN": xst,
        "Accept": "application/json",
        "Content-Type": "application/json",
    }


def _sleep_backoff(i: int, cap: int = 60) -> None:
    time.sleep(min(cap, 1.0))


# ----------------------------
# Client
# ----------------------------

class CapitalClient:
    def __init__(self, timeout: int = 30):
        self.timeout = timeout
        self.s: Optional[Session] = None
        self.http = requests.Session()

    def login(self, retries: int = 8, forever: bool = True) -> Session:
        """
        Login with retry/backoff.
        - If env vars are missing -> raise CapitalConfigError immediately.
        - If forever=True -> keep trying after exhausting retries (for long-running bots).
        - If forever=False -> raise after retries (for scripts/tests).
        """
        api_key, ident, pwd = _get_env_required()
        BASE = base_url()

        while True:
            last_err: Optional[Exception] = None
            for i in range(max(1, int(retries))):
                try:
                    r = self.http.post(
                        f"{BASE}/api/v1/session",
                        headers={
                            "X-CAP-API-KEY": api_key,
                            "Content-Type": "application/json",
                            "Accept": "application/json",
                        },
                        json={"identifier": ident, "password": pwd, "encryptedPassword": False},
                        timeout=self.timeout,
                    )

                    if r.status_code == 429:
                        # rate limit: for scripts/tests fail fast with a clear message
                        last_err = RuntimeError(f"Login rate-limited status=429 body={r.text[:200]}")
                        if not forever:
                            break
                        _sleep_backoff(i)
                        continue

                    if r.status_code in (401, 403):
                        # auth errors should not loop forever silently
                        raise CapitalAuthError(f"Login failed status={r.status_code} body={r.text[:200]}")

                    r.raise_for_status()

                    cst = r.headers.get("CST")
                    xst = r.headers.get("X-SECURITY-TOKEN")
                    if not cst or not xst:
                        raise RuntimeError("Login OK but missing CST/X-SECURITY-TOKEN headers")

                    self.s = Session(base=BASE, cst=cst, xst=xst)

                    # best-effort account selection
                    try:
                        self.ensure_account(os.environ.get("CAPITAL_ACCOUNT_ID"))
                    except Exception:
                        pass

                    return self.s

                except CapitalConfigError:
                    raise
                except CapitalAuthError:
                    # Auth errors should fail fast (otherwise scripts & daemons look "stuck")
                    raise
                except Exception as e:
                    last_err = e
                    _sleep_backoff(i)

            if not forever:
                raise RuntimeError(f"Login failed after {retries} retries. Last error: {repr(last_err)}")

            time.sleep(30)  # cool down then retry forever

    def _ensure(self) -> Session:
        if not self.s:
            # for daemon/bot behavior: try forever
            return self.login(forever=True)
        return self.s

    def request(
        self,
        method: str,
        path: str,
        *,
        params=None,
        json_body=None,
        data=None,
        retries: int = 6,
    ) -> requests.Response:
        api_key, _, _ = _get_env_required()
        sess = self._ensure()
        last_err: Optional[Exception] = None

        for i in range(max(1, int(retries))):
            r: Optional[requests.Response] = None
            try:
                r = self.http.request(
                    method,
                    f"{sess.base}{path}",
                    headers=_headers(api_key, sess.cst, sess.xst),
                    params=params,
                    json=json_body,
                    data=data,
                    timeout=self.timeout,
                )

                if r.status_code == 401:
                    # relogin once and retry
                    self.login(forever=True)
                    sess = self._ensure()
                    try:
                        self.ensure_account(os.environ.get("CAPITAL_ACCOUNT_ID"))
                    except Exception:
                        pass
                    continue

                if r.status_code == 429:
                    _sleep_backoff(i)
                    continue

                if r.status_code >= 500:
                    time.sleep(min(30, 2 ** i))
                    continue

                r.raise_for_status()
                return r

            except requests.exceptions.HTTPError as e:
                last_err = e
                if r is not None and 400 <= r.status_code < 500 and r.status_code not in (401, 429):
                    # non-retryable client errors
                    raise RuntimeError(f"HTTP {r.status_code} {method} {path} body={r.text[:300]}") from e
                time.sleep(min(30, 2 ** i))

            except Exception as e:
                last_err = e
                time.sleep(min(30, 2 ** i))

        raise RuntimeError(f"Request failed {method} {path}. Last error: {repr(last_err)}")

    # ----------------------------
    # account handling (best-effort)
    # ----------------------------

    def get_session(self) -> Dict[str, Any]:
        r = self.request("GET", "/api/v1/session")
        return r.json()

    def select_account(self, account_id: str) -> bool:
        try:
            r = self.request("PUT", "/api/v1/session", json_body={"accountId": str(account_id)}, retries=3)
            return r.status_code in (200, 204)
        except Exception:
            return False

    def ensure_account(self, account_id: Optional[str]) -> None:
        if not account_id:
            return
        try:
            sess = self.get_session()
            cur = sess.get("currentAccountId") or sess.get("accountId")
            if str(cur) != str(account_id):
                self.select_account(str(account_id))
        except Exception:
            return

    # ----------------------------
    # market / trading
    # ----------------------------

    def get_prices(self, epic: str, resolution: str, max_points: int) -> Dict[str, Any]:
        # Capital API hard-limit guard (observed: max=1000)
        try:
            mp = int(max_points)
        except Exception:
            mp = 250
        if mp > 1000:
            mp = 1000
        if mp < 1:
            mp = 1
        r = self.request("GET", f"/api/v1/prices/{epic}", params={"resolution": resolution, "max": mp})
        return r.json()

    def get_positions(self) -> Dict[str, Any]:
        return self.request("GET", "/api/v1/positions").json()

    def open_market(self, epic: str, direction: str, size: float) -> Dict[str, Any]:
        payload = {"epic": epic, "direction": direction, "size": float(size), "orderType": "MARKET"}
        # use json_body for consistency / correct encoding
        return self.request("POST", "/api/v1/positions", json_body=payload).json()

    def close_position(self, deal_id: str) -> Dict[str, Any]:
        r = self.request("DELETE", f"/api/v1/positions/{deal_id}")
        return r.json() if r.text else {}

    def confirm(self, deal_reference: str, timeout_sec: int = 30) -> Optional[Dict[str, Any]]:
        t0 = time.time()
        last = None
        while time.time() - t0 < timeout_sec:
            try:
                r = self.request("GET", f"/api/v1/confirms/{deal_reference}", retries=3)
                last = r.json()
                ds = (last.get("dealStatus") or "").upper()
                if ds in ("ACCEPTED", "REJECTED"):
                    return last
            except Exception:
                pass
            time.sleep(1)
        return last


def is_deal_open(positions_json: Dict[str, Any], deal_id: str) -> bool:
    for p in (positions_json or {}).get("positions", []) or []:
        pos = (p or {}).get("position") or {}
        if str(pos.get("dealId")) == str(deal_id):
            return True
    return False


def pick_position_dealid_from_confirm(conf: Dict[str, Any]) -> Optional[str]:
    aff = conf.get("affectedDeals") or []
    if isinstance(aff, list):
        for a in aff:
            if (a or {}).get("status") in ("OPENED", "PARTIALLY_OPENED"):
                did = (a or {}).get("dealId")
                if did:
                    return str(did)
    did = conf.get("dealId")
    return str(did) if did else None
