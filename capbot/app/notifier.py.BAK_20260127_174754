from __future__ import annotations

import os
import socket
import smtplib
import inspect
from typing import Dict, Any, Optional
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from capbot.notify.email_templates import render_email as tmpl_render, subject as tmpl_subject


def _safe_get(d: Dict[str, Any], *keys, default=None):
    cur = d
    for k in keys:
        if not isinstance(cur, dict) or k not in cur:
            return default
        cur = cur[k]
    return cur


def _env(name: str, default: str = "") -> str:
    v = os.getenv(name)
    return default if v is None else str(v)


def _send_smtp(subj: str, text_body: str, html_body: str, cfg: Optional[Dict[str, Any]] = None) -> None:
    cfg = cfg or {}

    host = _env("SMTP_HOST") or _safe_get(cfg, "smtp", "host", default="")
    port = int(_env("SMTP_PORT", "587") or _safe_get(cfg, "smtp", "port", default=587))
    user = _env("SMTP_USER") or _safe_get(cfg, "smtp", "user", default="")
    pw   = _env("SMTP_PASS") or _safe_get(cfg, "smtp", "pass", default="")
    to_  = _env("EMAIL_TO")  or _safe_get(cfg, "email", "to", default="")
    frm  = _env("EMAIL_FROM") or _safe_get(cfg, "email", "from", default=user)

    if not host or not to_ or not frm:
        raise RuntimeError(f"SMTP missing config (host/to/from). host={host!r} to={to_!r} from={frm!r}")

    msg = MIMEMultipart("alternative")
    msg["Subject"] = subj
    msg["From"] = frm
    msg["To"] = to_

    msg.attach(MIMEText(text_body or "", "plain", "utf-8"))
    msg.attach(MIMEText(html_body or "", "html", "utf-8"))

    with smtplib.SMTP(host, port, timeout=20) as s:
        s.ehlo()
        try:
            s.starttls()
            s.ehlo()
        except Exception:
            pass
        if user and pw:
            s.login(user, pw)
        s.sendmail(frm, [to_], msg.as_string())


def _render_email_compat(event: str, market: str, bot_id: str, payload: Dict[str, Any], meta: Dict[str, Any]):
    """
    Compat con distintas firmas de render_email().

    Hemos visto que tu render_email usa bot_id internamente (_label(bot_id)),
    así que el orden correcto típico es:
        render_email(event, bot_id, payload, meta)

    Y en algunos forks puede aceptar keyword args.
    """
    try:
        sig = inspect.signature(tmpl_render)
        params = list(sig.parameters.keys())

        # preferimos keyword call si soporta esos nombres
        if "event" in params and "bot_id" in params and "payload" in params and "meta" in params:
            kw = {"event": event, "bot_id": bot_id, "payload": payload, "meta": meta}
            if "market" in params:
                kw["market"] = market
            return tmpl_render(**kw)

        # firmas posicionales comunes
        if len(params) >= 4:
            # (event, bot_id, payload, meta, ...)
            return tmpl_render(event, bot_id, payload, meta)

        if len(params) == 3:
            # podría ser (event, bot_id, payload)
            return tmpl_render(event, bot_id, payload)

        # fallback ultra defensivo
        return tmpl_render(event, bot_id, payload, meta)

    except Exception:
        # fallback final sin introspección
        return tmpl_render(event, bot_id, payload, meta)
def email_event(enabled: bool, bot_id: str, event: str, data: Dict[str, Any], logfile=None, cfg: Optional[Dict[str, Any]] = None) -> None:
    if not enabled:
        return

    cfg = cfg or {}
    market = str(data.get("market") or cfg.get("market") or cfg.get("symbol") or "GER40")
    tf = str(data.get("timeframe") or cfg.get("timeframe") or cfg.get("resolution") or "5m")

    meta = {
        "bot_id": bot_id,
        "host": socket.gethostname(),
        "service": data.get("service") or "",
        "config_path": data.get("config_path") or cfg.get("_config_path") or cfg.get("config_path") or "",
        "logfile": data.get("logfile") or (str(logfile) if logfile else ""),
        "timeframe": tf,
        "market": market,
        "ts_utc": data.get("ts_utc") or data.get("ts") or "",
        "ts_local": data.get("ts_local") or "",
    }

    # SUBJECT: simple y limpio como quieres
    subj = tmpl_subject(event, payload, meta)

    text_body, html_body = _render_email_compat(event=event, market=market, bot_id=bot_id, payload=data or {}, meta=meta)

    try:
        _send_smtp(subj, text_body, html_body, cfg=cfg)
        print(f"[EMAIL OK] {subj} event={event}")
    except Exception as e:
        print(f"[EMAIL_ERR] {subj} event={event} -> {repr(e)}")


def email_startup(enabled: bool, bot_id: str, cfg: dict, logfile: str = "") -> None:
    if not enabled:
        return
    data = {
        "event": "STARTED",
        "bot_id": bot_id,
        "market": (cfg.get("market") or cfg.get("symbol") or "GER40"),
        "timeframe": (cfg.get("timeframe") or cfg.get("resolution") or "5m"),
        "strategy": ((cfg.get("strategy") or {}).get("module") or ""),
        "config_path": cfg.get("_config_path") or cfg.get("config_path") or "",
        "logfile": logfile or "",
    }
    email_event(True, bot_id, "STARTED", data, logfile=logfile, cfg=cfg)
