from __future__ import annotations

import os
import time
from dataclasses import asdict
from typing import Any, Dict, Optional, Tuple

import pandas as pd

from capbot.broker.capital_client import CapitalClient, pick_position_dealid_from_confirm
from capbot.data.prices import prices_to_df
from capbot.domain.lock import InstanceLock
from capbot.domain.logger import log_line
from capbot.domain.paths import bot_paths
from capbot.domain.risk import calc_position_size
from capbot.domain.schedule import RTH
from capbot.domain.state_store import load_state, save_state_atomic
from capbot.domain.trade_log import ensure_header, append_row
from capbot.strategies.loader import load_strategy


# ----------------------------
# Time helpers (robust)
# ----------------------------

def to_utc_ts(x: Any) -> pd.Timestamp:
    """
    Convert various timestamp shapes to tz-aware pd.Timestamp in UTC.
    Accepts: pd.Timestamp, datetime, str, int/float epoch (s/ms).
    Returns "now UTC" on failure.
    """
    now = pd.Timestamp.now(tz="UTC")

    if x is None:
        return now

    try:
        if isinstance(x, pd.Timestamp):
            ts = x
        else:
            # epoch heuristic: ms if huge
            if isinstance(x, (int, float)):
                unit = "ms" if x > 10_000_000_000 else "s"
                ts = pd.to_datetime(x, unit=unit, utc=True, errors="coerce")
            else:
                ts = pd.to_datetime(x, utc=True, errors="coerce")
    except Exception:
        return now

    if ts is pd.NaT:
        return now

    # tz enforce
    try:
        if ts.tzinfo is None:
            ts = ts.tz_localize("UTC")
        else:
            ts = ts.tz_convert("UTC")
    except Exception:
        return now

    # anti-1970 / junk
    if ts.year < 2000:
        return now

    return ts


def ts_to_iso(ts: Any) -> str:
    try:
        return to_utc_ts(ts).isoformat()
    except Exception:
        return ""


def rth_is_open(rth: RTH, ts_utc: pd.Timestamp) -> bool:
    """Delegate to schedule.RTH.in_rth(). Fail-closed."""
    try:
        return bool(rth.in_rth(ts_utc))
    except Exception:
        return False



# ----------------------------
# Strategy adapter (robust)
# ----------------------------

def call_strategy_signal(strategy: Any, df: pd.DataFrame, params: Dict[str, Any]) -> Any:
    """
    Tries, in order:
      - strategy.signal(df, params)
      - strategy.signal(df)
      - strategy.signal_on_row(df, i=-2, params)
      - strategy.signal_on_row(df, i=-2)
    """
    if hasattr(strategy, "signal"):
        try:
            return strategy.signal(df, params)
        except TypeError:
            return strategy.signal(df)

    if hasattr(strategy, "signal_on_row"):
        i = -2
        try:
            return strategy.signal_on_row(df, i, params)
        except TypeError:
            return strategy.signal_on_row(df, i)

    raise AttributeError(f"Strategy {type(strategy).__name__} has no signal method")


def call_strategy_enrich(strategy: Any, df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
    if hasattr(strategy, "enrich"):
        try:
            out = strategy.enrich(df, params)
        except TypeError:
            out = strategy.enrich(df)
        if isinstance(out, pd.DataFrame):
            return out
    return df


# ----------------------------
# VIS helpers
# ----------------------------

def _fmt(x: Any, nd: int = 2) -> str:
    try:
        if x is None:
            return "na"
        f = float(x)
        if pd.isna(f):
            return "na"
        return f"{f:.{nd}f}"
    except Exception:
        return "na"


def print_vis(logfile, ts_ny: pd.Timestamp, ts_utc: pd.Timestamp, gates: Dict[str, bool], row: pd.Series, sig: Any, entry_ok: bool) -> None:
    th = "✅" if gates.get("thu_ok") else "❌"
    rth = "✅" if gates.get("rth_ok") else "❌"
    now_rth = "✅" if gates.get("now_rth_ok") else "❌"
    bars_mark = "✅" if gates.get("bars_ok") else "❌"
    bars_today = gates.get("bars_today", "na")
    bars_need = gates.get("bars_need", "na")

    def _ok(v: Any) -> bool:
        try:
            if v is None:
                return False
            f = float(v)
            return not pd.isna(f)
        except Exception:
            return False

    def _mark(v: Any) -> str:
        return "✅" if _ok(v) else "❌"

    body = row.get("body_ratio")
    volr = row.get("vol_rel")
    rsi = row.get("rsi14")
    atr = row.get("atr14")
    bear3 = row.get("bear_prev3")
    bull3 = row.get("bull_prev3")

    long_sig = bool(getattr(sig, "direction", "").upper() == "BUY") if sig is not None else False
    short_sig = bool(getattr(sig, "direction", "").upper() == "SELL") if sig is not None else False

    sig_ok = (sig is not None)
    sig_dir = str(getattr(sig, "direction", "")).upper() if sig_ok else ""
    sig_mark = "✅" if sig_ok else "❌"

    
    # --- VIS thresholds (solo para mostrar comparaciones) ---
    body_min = float(cfg.get("vis_body_min", 0.40))
    vol_min  = float(cfg.get("vis_vol_min", 0.80))
    rsi_min  = float(cfg.get("vis_rsi_min", 45.0))
    rsi_max  = float(cfg.get("vis_rsi_max", 55.0))
    atr_min  = float(cfg.get("vis_atr_min", 0.0))

    # valores actuales
    body = float(row_vis.get("body") or 0.0)
    volr = float(row_vis.get("vol_ratio") or row_vis.get("vol_ok") or 0.0)
    rsi  = float(row_vis.get("rsi14") or 0.0)
    atr  = float(row_vis.get("atr14") or 0.0)
    log_line(
        logfile,
        (
        f"VIS_NY | sigNY={ts_ny:%Y-%m-%d %H:%M} | sigUTC={ts_utc:%Y-%m-%d %H:%MZ} | "
        f"THU {th} | RTH {rth} | NOW_RTH {now_rth} | "
        f"BARS {bars_mark} {bars_today}/{bars_need} | "
        f"SIG {sig_mark} {sig_dir} | "
        f"ENTER {('✅' if (entry_ok and is_new_bar and (not has_pos)) else '❌')} | "
        f"body={body:.2f}>={body_min:.2f} | "
        f"vol={volr:.2f}>={vol_min:.2f} | "
        f"rsi={rsi:.1f} in[{rsi_min:.1f},{rsi_max:.1f}] | "
        f"atr={atr:.2f}>={atr_min:.2f}"
        ),
        f"px={close_px:.1f} entry={entry_px:.1f} sl={sl:.1f} tp={tp:.1f} size={size:.2f} | "
        f"body={body:.2f} vol={volr:.2f} rsi={rsi:.1f} atr={atr:.2f} bear3={bear3} bull3={bull3}"
        f"BODY {_mark(body)} {_fmt(body)} | VOL {_mark(volr)} {_fmt(volr)} | RSI {_mark(rsi)} {_fmt(rsi,1)} | ATR {_mark(atr)} {_fmt(atr)} | "
        f"bear3 {_mark(bear3)} {bear3} | bull3 {_mark(bull3)} {bull3}"
    )
    log_line(
        logfile,
        f"LONG={'✅' if long_sig else '❌'} SHORT={'✅' if short_sig else '❌'}"
    )
    log_line(
        logfile,
        f"ENTRY {'✅' if entry_ok else '❌'}"
    )


# ----------------------------
# Position mgmt (simple + robust)
# ----------------------------

def compute_sl_tp(direction: str, entry: float, atr_entry: float) -> Tuple[float, float]:
    # Spec: SL=1ATR, TP=3ATR (ATR constant at entry)
    if direction.upper() == "BUY":
        return (entry - 1.0 * atr_entry, entry + 3.0 * atr_entry)
    return (entry + 1.0 * atr_entry, entry - 3.0 * atr_entry)


def update_trailing(direction: str, entry: float, atr_entry: float, close_px: float, sl: float) -> float:
    """
    End-of-bar trailing:
      - BE lock once price moved >= +1 ATR in favor.
      - Trail with 1 ATR offset from close (conservative).
    """
    d = direction.upper()
    if atr_entry <= 0:
        return sl

    if d == "BUY":
        if close_px >= entry + 1.0 * atr_entry:
            sl = max(sl, entry)  # BE
        sl = max(sl, close_px - 1.0 * atr_entry)
        return sl
    else:
        if close_px <= entry - 1.0 * atr_entry:
            sl = min(sl, entry)  # BE for short
        sl = min(sl, close_px + 1.0 * atr_entry)
        return sl


def should_exit(direction: str, close_px: float, sl: float, tp: float) -> Optional[str]:
    d = direction.upper()
    if d == "BUY":
        if close_px >= tp:
            return "TP"
        if close_px <= sl:
            return "SL"
    else:
        if close_px <= tp:
            return "TP"
        if close_px >= sl:
            return "SL"
    return None


# ----------------------------
# Main bot loop
# ----------------------------

def run_bot(cfg: Dict[str, Any], once: bool = False) -> None:
    bot_id = str(cfg.get("bot_id") or "sp500_5m_rth")
    state_path, csv_path, logfile, lock_path = bot_paths(bot_id)

    lock = InstanceLock(lock_path)
    lock.acquire()
    try:
        ensure_header(csv_path)

        def save_state(st: Dict[str, Any]) -> None:
            save_state_atomic(state_path, st)

        st: Dict[str, Any] = load_state(state_path) or {}

        poll = int(cfg.get("poll_seconds", 30))

        market = cfg.get("market") or {}
        epic = str(market.get("epic") or "").strip()
        resolution = str(market.get("resolution") or "MINUTE_5").strip()
        warmup = int(market.get("warmup_bars", 250))
        if not epic:
            raise RuntimeError("Config error: market.epic is missing")

        schedule_cfg = cfg.get("schedule") or {}
        tz_name = str(schedule_cfg.get("timezone") or "America/New_York")
        rth_enabled = bool(schedule_cfg.get("rth_enabled", True))
        rth_start = str(schedule_cfg.get("rth_start") or "09:30")
        rth_end = str(schedule_cfg.get("rth_end") or "16:00")
        disable_thursday_utc = bool(schedule_cfg.get("disable_thursday_utc", True))

        rth = RTH(
            tz_name=tz_name,
            start_hh=int(rth_start.split(":")[0]),
            start_mm=int(rth_start.split(":")[1]),
            end_hh=int(rth_end.split(":")[0]),
            end_mm=int(rth_end.split(":")[1]),
        )

        risk = cfg.get("risk") or {}
        bot_equity = float(risk.get("bot_equity", 25000))
        risk_pct = float(risk.get("risk_pct", 0.02))
        value_per_point_per_size = float(risk.get("value_per_point_per_size", 1.0))

        # Strategy
        strat_spec = str((cfg.get("strategy") or {}).get("module") or "").strip()
        if not strat_spec:
            raise RuntimeError("Config error: strategy.module is missing")
        strategy = load_strategy(strat_spec)
        strat_params = dict((cfg.get("strategy") or {}).get("params") or {})
        # the strategy expects disable_thursday_utc param (True means block Thu)
        strat_params.setdefault("disable_thursday_utc", disable_thursday_utc)

        # Broker
        client = CapitalClient(timeout=30)
        sess = client.login()
        log_line(logfile, f"BOOT bot_id={bot_id} epic={epic} res={resolution} rth={tz_name} {rth_start}-{rth_end} disable_thu_utc={disable_thursday_utc}")
        try:
            from capbot.app import notifier
            notifier.email_startup(True, bot_id, cfg, logfile=logfile)
        except Exception as _e:
            log_line(logfile, "EMAIL_ERR_STARTUP " + repr(_e))
        log_line(logfile, f"CAPITAL session base={sess.base}")

        account_id = ((cfg.get("account") or {}).get("account_id")) or os.environ.get("CAPITAL_ACCOUNT_ID")
        try:
            client.ensure_account(str(account_id) if account_id else None)
        except Exception:
            pass

        while True:
            try:
                req_points = int(min(5000, max(warmup, warmup * 4)))
                req_points = min(int(req_points), 1000)
                req_points = min(int(req_points), 1000)
                j = client.get_prices(epic, resolution, req_points)
                df = prices_to_df(j)
                if df is None or df.empty or len(df) < 3:
                    log_line(logfile, "WARN not enough bars yet")
                    if once:
                        return
                    time.sleep(poll)
                    continue

                # Keep a tz-aware DatetimeIndex in UTC
                df = df.copy()
                df["time"] = pd.to_datetime(df["time"], utc=True, errors="coerce")
                df = df.dropna(subset=["time"]).sort_values("time").drop_duplicates("time")
                df = df.reset_index(drop=True)
                df.index = pd.DatetimeIndex(df["time"])
                # we keep 'time' column too (harmless)
                if df.index.tz is None:
                    df.index = df.index.tz_localize("UTC")
                else:
                    df.index = df.index.tz_convert("UTC")


                # --- Signal dataframe: ONLY RTH bars (for indicators + strategy) ---
                if rth_enabled:
                    mask = [rth_is_open(rth, t) for t in df.index]
                    df_sig = df.loc[mask].copy()
                else:
                    df_sig = df.copy()

                # si no hay suficientes RTH bars para RSI/ATR/vol_ma, no intentamos señal
                if df_sig is None or df_sig.empty or len(df_sig) < 25:
                    log_line(logfile, f"WARN not enough RTH bars | rth_rows={0 if df_sig is None else len(df_sig)} raw_rows={len(df)} req_points={locals().get('req_points','?')}")
                    if once:
                        return
                    time.sleep(poll)
                    continue


                # --- Signal dataframe: ONLY RTH bars (for indicators + strategy) ---
                try:
                    df_sig = df[df.index.map(lambda t: rth_is_open(rth, t))].copy()
                except Exception:
                    df_sig = df.copy()

                if df_sig is None or df_sig.empty or len(df_sig) < 25:
                    # 25 ~= enough for SMA20 + margin
                    log_line(logfile, f"WARN not enough RTH bars for signal/enrich | rth_rows={0 if df_sig is None else len(df_sig)} total_rows={len(df)}")
                    df_sig = df.copy()

                # last CLOSED bar
                # last CLOSED bar (robusto ante gaps)
                expected = pd.Timedelta(minutes=5)
                r = str(resolution).upper().strip()
                if r in ("MINUTE_1","MINUTE1","MINUTE"):
                    expected = pd.Timedelta(minutes=1)
                elif r in ("MINUTE_15","MINUTE15"):
                    expected = pd.Timedelta(minutes=15)
                elif r in ("HOUR","HOUR_1","HOUR1"):
                    expected = pd.Timedelta(hours=1)

                sig_i = -2
                try:
                    idx = df.index
                    for k in range(2, min(50, len(idx))):
                        t0 = to_utc_ts(idx[-k])
                        t1 = to_utc_ts(idx[-k+1])
                        if (t1 - t0) == expected:
                            sig_i = -k
                            break
                except Exception:
                    sig_i = -2

                ts_utc = to_utc_ts(df.index[sig_i])
                ts_ny = ts_utc.tz_convert("America/New_York")

                # gates evaluated on the SIGNAL bar timestamp
                is_thu_utc = (ts_utc.weekday() == 3)
                thu_ok = (not disable_thursday_utc) or (not is_thu_utc)
                rth_ok = (not rth_enabled) or rth_is_open(rth, ts_utc)

                gates = {"thu_ok": bool(thu_ok), "rth_ok": bool(rth_ok)}

                now_utc = pd.Timestamp.now(tz="UTC")
                now_rth_ok = (not rth_enabled) or rth_is_open(rth, now_utc)
                gates["now_rth_ok"] = bool(now_rth_ok)



                # ---- Gate: velas RTH de HOY (NY) listas (primera hora) ----
                # Default: 12 velas en 5m = 1h. Puedes override en config: schedule.min_rth_bars
                try:
                    r = str(resolution).upper().strip()
                    default_need = 12  # MINUTE_5
                    if r in ("MINUTE_1","MINUTE1","MINUTE"):
                        default_need = 60
                    elif r in ("MINUTE_15","MINUTE15"):
                        default_need = 4
                    elif r in ("HOUR","HOUR_1","HOUR1"):
                        default_need = 1

                    need = int((schedule_cfg.get("min_rth_bars", 0) or 0)) or int(default_need)

                    # contamos velas RTH del MISMO día NY que la señal, hasta ts_utc (incl.)
                    idx = df.index
                    idx2 = idx[idx <= ts_utc]
                    ny_dates = idx2.tz_convert(tz_name).normalize()
                    sig_day = ts_utc.tz_convert(tz_name).normalize()
                    same_day = (ny_dates == sig_day)

                    # rth mask en UTC (función rth_is_open ya convierte)
                    rth_mask = [rth_is_open(rth, t) for t in idx2]
                    bars_today = int(sum(1 for ok, sd in zip(rth_mask, same_day) if ok and sd))

                    bars_ok = bool(bars_today >= need)
                except Exception:
                    need = 12
                    bars_today = 0
                    bars_ok = False

                gates["bars_ok"] = bool(bars_ok)
                gates["bars_today"] = int(bars_today)
                gates["bars_need"] = int(need)
                # enrich for VIS + strategy
                df_en = call_strategy_enrich(strategy, df_sig, strat_params)
                if df_en is None or df_en.empty:
                    df_en = df

                # compute signal (strategy will choose -2 internally if using signal())
                sig = call_strategy_signal(strategy, df_en, strat_params)

                # open-position tracking
                pos = st.get("position") or {}
                has_pos = bool(pos.get("deal_id"))

                # entry allowed? (debug VIS still prints regardless)
                entry_ok = bool((sig is not None) and (not has_pos) and gates["thu_ok"] and gates["rth_ok"] and gates.get("now_rth_ok", True) and gates.get("bars_ok", True))

                # VIS (always)
                try:
                    row_vis = df_en.iloc[sig_i] if len(df_en) >= abs(sig_i) else df_sig.iloc[sig_i]
                except Exception:
                    row_vis = df.iloc[sig_i]
                print_vis(logfile, ts_ny, ts_utc, gates, row_vis, sig, entry_ok)

                # Ensure we only take actions once per CLOSED bar
                last_bar_iso = st.get("last_bar_iso", "")
                this_bar_iso = ts_to_iso(ts_utc)

                is_new_bar = (this_bar_iso != last_bar_iso)

                stale_count = int(st.get('stale_count') or 0)
                if not is_new_bar:
                    stale_count += 1
                    st['stale_count'] = stale_count
                    # log cada 10 polls para no spamear
                    if stale_count % 2 == 0:
                        open_ts = df.index[-1] if len(df.index) else None
                        log_line(logfile, f"STALE no new closed bar | closed={this_bar_iso} open={ts_to_iso(open_ts)} rows={len(df)}")
                else:
                    if stale_count:
                        st['stale_count'] = 0

                # --- Manage existing position on new bars only ---
                if has_pos and is_new_bar:
                    close_px = float(df.iloc[sig_i]["close"])
                    direction = str(pos.get("direction") or "").upper()
                    entry_px = float(pos.get("entry_price") or 0.0)
                    atr_entry = float(pos.get("atr_entry") or 0.0)
                    sl = float(pos.get("sl") or entry_px)
                    tp = float(pos.get("tp") or entry_px)

                    bars_held = int(pos.get("bars_held") or 0) + 1

                    # trailing end-of-bar
                    sl2 = update_trailing(direction, entry_px, atr_entry, close_px, sl)
                    # --- Trail stage notifications (1R->BE, 2R->SL=+1R) ---
                    try:
                        # 1R en puntos basado en SL inicial guardado en pos['sl'] (antes del update)
                        r_points = float(abs(entry_px - sl))
                        stage = int(pos.get("trail_stage") or 0)  # 0 none, 1 reached 1R, 2 reached 2R
                        new_stage = stage

                        if r_points > 0:
                            if direction == "BUY":
                                if stage < 1 and close_px >= entry_px + 1.0 * r_points:
                                    new_stage = 1
                                if stage < 2 and close_px >= entry_px + 2.0 * r_points:
                                    new_stage = 2
                            elif direction == "SELL":
                                if stage < 1 and close_px <= entry_px - 1.0 * r_points:
                                    new_stage = 1
                                if stage < 2 and close_px <= entry_px - 2.0 * r_points:
                                    new_stage = 2

                        if new_stage != stage:
                            pos["trail_stage"] = new_stage
                            st["position"] = pos
                            save_state(st)

                            from capbot.app import notifier
                            notifier.email_event(
                                True,
                                bot_id,
                                f"TRAIL_{new_stage}R",
                                {
                                    "service": "capbot-sp500_5m_rth",
                                    "config_path": cfg.get("_config_path") or cfg.get("config_path") or "",
                                    "market": epic,
                                    "timeframe": resolution,
                                    "direction": direction,
                                    "deal_id": str(pos.get("deal_id") or ""),
                                    "entry_price": entry_px,
                                    "close_price": close_px,
                                    "r_points": r_points,
                                    "sl_prev": sl,
                                    "sl_new": sl2,
                                    "tp": tp,
                                    "bars_held": bars_held,
                                },
                                logfile=logfile,
                                cfg=cfg,
                            )
                    except Exception as _e:
                        log_line(logfile, f"EMAIL_ERR trail {repr(_e)}")


                    # exit checks
                    reason = should_exit(direction, close_px, sl2, tp)
                    if reason is None and bars_held >= 24:
                        reason = "TIME"

                    pos.update({"sl": sl2, "bars_held": bars_held})
                    st["position"] = pos
                    save_state(st)

                    if reason:
                        deal_id = str(pos.get("deal_id") or "")
                        log_line(logfile, f"EXIT_{reason} deal_id={deal_id} close={close_px} sl={sl2} tp={tp} bars={bars_held}")

                        # --- actually close on broker ---
                        ok = False
                        try:
                            log_line(logfile, f"CLOSE_REQ deal_id={deal_id} reason={reason}")
                            conf = client.close_position(deal_id)
                            ok = bool(conf)
                            log_line(logfile, f"CLOSE_OK deal_id={deal_id} ok={ok}")
                        except Exception as e:
                            log_line(logfile, f"CLOSE_ERR deal_id={deal_id} {repr(e)}")

                        # --- email only if close succeeded ---
                        if ok:
                            try:
                                from capbot.app import notifier
                                # --- PnL estimate ---
                                _size = float(pos.get("size") or 0.0)
                                _vpp  = float(value_per_point_per_size or 1.0)
                                _pnl_points = (close_px - entry_px) if direction == "BUY" else (entry_px - close_px)
                                _pnl_cash   = _pnl_points * _size * _vpp
                                _risk_pts   = float(pos.get("risk_points") or abs(entry_px - float(pos.get("sl_init") or sl2 or entry_px)) or 0.0)
                                _r_mult     = (_pnl_points / _risk_pts) if _risk_pts else None

                                notifier.email_event(
                                True, bot_id, f"EXIT_{reason}",
                                {
                                "service": "capbot-sp500_5m_rth",
                                "config_path": cfg.get("_config_path") or cfg.get("config_path") or "",
                                "market": epic,
                                "timeframe": resolution,
                                "reason": reason,
                                "direction": direction,
                                "deal_id": deal_id,
                                "size": _size,
                                "entry_price_est": float(entry_px),
                                "exit_price_est": float(close_px),
                                "sl": float(sl2),
                                "tp": float(tp),
                                "atr_entry": float(atr_entry),
                                "pnl_points_est": float(_pnl_points),
                                "pnl_cash_est": float(_pnl_cash),
                                "r_multiple_est": _r_mult,
                                "bars_held": bars_held,
                                },
                                logfile=logfile,
                                cfg=cfg,
                                )or cfg.get("config_path") or "",
                                "market": epic,
                                "timeframe": resolution,
                                "reason": reason,
                                "direction": direction,
                                "deal_id": deal_id,
                                "close_price": close_px,
                                "sl": sl2,
                                "tp": tp,
                                "pnl_points_est": (close_px - entry_px) if direction=="BUY" else (entry_px - close_px),
                                "pnl_cash_est": ((close_px - entry_px) if direction=="BUY" else (entry_px - close_px)) * float(pos.get("size") or 0.0) * (value_per_point_per_size if "value_per_point_per_size" in locals() else 0.0),
                                "size": float(pos.get("size") or 0.0),
                                "entry_price": entry_px,
                                "bars_held": bars_held,
                                },
                                logfile=logfile,
                                cfg=cfg,
                                )
                            except Exception as _e:
                                log_line(logfile, f"EMAIL_ERR_EXIT {repr(_e)}")

                        # log trade (best effort)
                        try:
                            append_row(csv_path, {
                                "entry_time": pos.get("entry_time"),
                                "exit_time": this_bar_iso,
                                "direction": direction,
                                "size": pos.get("size"),
                                "entry_price_est": entry_px,
                                "exit_price_est": close_px,
                                "exit_reason": reason,
                                "position_deal_id": deal_id,
                                "meta_json": str({"close_ok": ok}),
                            })
                        except Exception:
                            pass

                        # clear local state ONLY if we really closed
                        if ok:
                            st["position"] = {}
                            save_state(st)

                # --- Entry on new bars only ---
                if entry_ok and is_new_bar:
                    # extract signal info
                    direction = str(getattr(sig, "direction", "")).upper()
                    entry_px = float(getattr(sig, "entry_price", df_sig.iloc[sig_i]["close"]))
                    atr_entry = float(getattr(sig, "atr_entry", row_vis.get("atr14") or 0.0) or 0.0)
                    sl, tp = compute_sl_tp(direction, entry_px, atr_entry)
                    r_points = float(abs(entry_px - sl)) if atr_entry > 0 else float(atr_entry or 1.0)

                    size = calc_position_size(bot_equity, risk_pct, r_points, value_per_point_per_size)

                    log_line(logfile, f"ENTRY_REQ dir={direction} size={size} entry={entry_px} sl={sl} tp={tp} atr_entry={atr_entry}")
                    try:
                        o = client.open_market(epic, direction, float(size))
                        deal_ref = (o or {}).get("dealReference") or (o or {}).get("deal_reference")
                        conf = client.confirm(str(deal_ref)) if deal_ref else None
                        deal_id = pick_position_dealid_from_confirm(conf or {}) if conf else None
                        if not deal_id:
                            # fallback: sometimes confirm returns dealId at root
                            deal_id = (conf or {}).get("dealId")
                        if not deal_id:
                            raise RuntimeError(f"No deal_id from confirm. resp={o} conf={conf}")

                        st["position"] = {
                            "deal_id": str(deal_id),
                            "direction": direction,
                            "size": float(size),
                            "entry_price": entry_px,
                            "atr_entry": atr_entry,
                            "sl": sl,
                            "tp": tp,
                            "bars_held": 0,
                            "entry_time": this_bar_iso,
                        }
                        save_state(st)

                        log_line(logfile, f"ENTRY_OK deal_id={deal_id}")
                        try:
                            from capbot.app import notifier
                            notifier.email_event(
                            True, bot_id, "ENTRY_OK",
                            {
                                "service": "capbot-sp500_5m_rth",
                                "config_path": cfg.get("_config_path") or cfg.get("config_path") or "",
                                "market": epic,
                                "timeframe": resolution,
                                "direction": direction,
                                "deal_id": deal_id,
                                "size": float(size),
                                "entry_price_est": float(entry_px),
                                "sl": float(sl),
                                "tp": float(tp),
                                "atr_entry": float(atr_entry),
                                "risk_points": float(abs(entry_px - sl)),
                                "tp_r": float(abs(tp - entry_px) / (abs(entry_px - sl) or 1.0)),
                            },
                            logfile=logfile,
                            cfg=cfg,
                        )or cfg.get("config_path") or "",
                                    "market": epic,
                                    "timeframe": resolution,
                                    "direction": direction,
                                    "size": size,
                                    "entry_price": entry_px,
                                    "sl": sl,
                                    "tp": tp,
                                    "deal_id": deal_id,
                                },
                                logfile=logfile,
                                cfg=cfg,
                            )
                        except Exception as _e:
                            log_line(logfile, f"EMAIL_ERR entry {repr(_e)}")

                        try:
                            from capbot.app import notifier
                            notifier.email_event(True,
                                bot_id,
                                "ENTRY_OK",
                                {
                                    "service": "capbot-sp500_5m_rth.service",
                                    "deal_id": deal_id,
                                    "deal_ref": deal_ref,
                                    "epic": epic,
                                    "resolution": resolution,
                                    "direction": direction,
                                    "size": size,
                                    "entry_price": entry_px,
                                    "sl": sl,
                                    "tp": tp,
                                },
                                logfile=logfile,
                                cfg=cfg,
                            )
                        except Exception as _e:
                            log_line(logfile, f"EMAIL_ERR_ENTRY {repr(_e)}")

                    except Exception as e:
                        log_line(logfile, f"ERROR entry failed {repr(e)}")

                # mark bar processed
                st["last_bar_iso"] = this_bar_iso
                save_state(st)

                if once:
                    return

                time.sleep(poll)

            except Exception as e:
                log_line(logfile, f"ERROR loop {repr(e)}")
                if once:
                    raise
                time.sleep(min(60, poll))

    finally:
        try:
            lock.release()
        except Exception:
            pass
