from __future__ import annotations
from pathlib import Path
import time

import logging
import json
import datetime as _dt
from typing import Any



log = logging.getLogger(__name__)

def _json_default(o: Any):
    # Nunca explotes por tipos raros en payload (Path, datetime, etc)
    try:
        if isinstance(o, Path):
            return str(o)
    except Exception:
        pass

    try:
        import datetime as _dt
        if isinstance(o, (_dt.datetime, _dt.date)):
            return o.isoformat()
    except Exception:
        pass

    try:
        if isinstance(o, bytes):
            return o.decode("utf-8", "replace")
    except Exception:
        pass

    # fallback estable
    return str(o)
# --- STARTUP/SPAM GUARD (only for startup-ish events) ---
_DEDUPE_PATH = Path("/tmp/capbot_email_dedupe.json")

# STARTUP dedupe cooldown (seconds).
# - Default: 60s (so you can restart and still get a startup email soon)
# - Set CAPBOT_STARTUP_DEDUPE_SEC=0 to disable startup dedupe completely.
def _startup_dedupe_sec_default() -> int:
    try:
        return int(os.getenv("CAPBOT_STARTUP_DEDUPE_SEC", "60"))
    except Exception:
        return 60

def _should_dedupe_startup(bot_id: str, event: str, cooldown_sec: int = 1800) -> bool:
    # Only dedupe noisy events. Keep trade/alert emails untouched.
    if cooldown_sec is None:
        cooldown_sec = _startup_dedupe_sec_default()
    if int(cooldown_sec) <= 0:
        return False
    noisy = {"STARTUP", "SERVICE_START", "BOOT"}
    if event not in noisy:
        return False
    now = int(time.time())
    try:
        data = json.loads(_DEDUPE_PATH.read_text(encoding="utf-8")) if _DEDUPE_PATH.exists() else {}
    except Exception:
        data = {}
    key = f"{bot_id}:{event}"
    last = int(data.get(key, 0) or 0)
    if now - last < cooldown_sec:
        return True
    data[key] = now
    try:
        _DEDUPE_PATH.write_text(json.dumps(data, indent=2), encoding="utf-8")
    except Exception:
        pass
    return False
# --- end guard ---



def _build_email_meta(bot_id: str, event: str, *, logfile: str = "", cfg=None) -> dict:
    try:
        import os
        host = os.uname().nodename
    except Exception:
        host = ""
    now_utc = _dt.datetime.now(_dt.timezone.utc)
    try:
        now_local = _dt.datetime.now().astimezone()
        ts_local = now_local.isoformat()
    except Exception:
        ts_local = ""
    config_path = ""
    build = ""
    try:
        if isinstance(cfg, dict):
            config_path = str(cfg.get("config_path") or "")
            build = str(cfg.get("build") or "")
    except Exception:
        pass
    return {
        "ts_utc": now_utc.isoformat(),
        "ts_local": ts_local,
        "host": host,
        "service": "capbot",
        "bot_id": str(bot_id),
        "event": str(event),
        "config_path": config_path,
        "logfile": str(logfile or ""),
        "build": build,
    }


def email_event(ok: bool, bot_id: str, event: str, payload: Any, logfile: str = "", cfg=None) -> bool:
    """
    SMTP email sender.

    Required env:
      EMAIL_TO, SMTP_HOST, SMTP_PORT (default 587), SMTP_USER, SMTP_PASS
    Optional:
      EMAIL_FROM (defaults to EMAIL_TO)

    IMPORTANT: Never raise to caller (do not break trading loop).
    Returns True if sent, False otherwise.
    """
    import os, json, smtplib, ssl
    from email.message import EmailMessage

    try:
        to_addr = os.environ.get("EMAIL_TO") or os.environ.get("MAIL_TO")
        host = os.environ.get("SMTP_HOST")
        port = int(os.environ.get("SMTP_PORT", "587"))
        user = os.environ.get("SMTP_USER")
        pwd  = os.environ.get("SMTP_PASS")
        from_addr = os.environ.get("EMAIL_FROM") or to_addr

        if not to_addr or not host or not user or not pwd:
            log.warning("EMAIL_SKIPPED missing env vars: EMAIL_TO/SMTP_HOST/SMTP_USER/SMTP_PASS")
            return False


        # --- EMAIL TEMPLATE (pretty subject + HTML) with safe fallback ---


        meta = _build_email_meta(bot_id, event, logfile=logfile, cfg=cfg)



        msg = EmailMessage()


        msg["To"] = to_addr


        msg["From"] = from_addr



        subj = None


        text_body = None


        html_body = None



        try:


            from capbot.notify.email_templates import subject as _tmpl_subject, render_email as _tmpl_render


            payload_dict = payload if isinstance(payload, dict) else {"payload": payload}


            subj = _tmpl_subject(str(event), payload_dict, meta)


            text_body, html_body = _tmpl_render(str(event), str(bot_id), payload_dict, meta)


        except Exception:


            subj = f"[{bot_id}] {event} {'OK' if ok else 'FAIL'}"


            body = {


                "ok": ok,


                "bot_id": bot_id,


                "event": event,


                "payload": payload,


                "logfile": logfile,


                "meta": meta,


            }


            text_body = json.dumps(body, indent=2, ensure_ascii=False, default=_json_default)


            html_body = None



        msg["Subject"] = subj


        msg.set_content((text_body or "").strip() + "\n")


        if html_body:


            msg.add_alternative(html_body, subtype="html")
        if _should_dedupe_startup(str(bot_id), str(event)):
            log.info("EMAIL_SKIPPED: dedupe %s %s", bot_id, event)
            return False

        ctx = ssl.create_default_context()
        with smtplib.SMTP(host, port, timeout=25) as s:
            s.ehlo()
            if port in (587, 25):
                s.starttls(context=ctx)
                s.ehlo()
            s.login(user, pwd)
            s.send_message(msg)

        log.info("EMAIL_SENT to=%s subj=%s", to_addr, subj)
        return True

    except Exception as e:
        log.exception("EMAIL_FAILED: %r", e)
        return False


def email_startup(enabled: bool, bot_id: str, body: dict, subject_prefix: str = "") -> bool:
    # compat wrapper:
    # - engine pasa el logfile como 4ยบ arg (antes se llamaba subject_prefix)
    # - fallback: body["logfile"]
    try:
        logfile = ""
        if isinstance(subject_prefix, str) and subject_prefix.strip():
            logfile = subject_prefix.strip()
        if not logfile and isinstance(body, dict):
            logfile = str(body.get("logfile") or "")
        return email_event(bool(enabled), str(bot_id), "STARTUP", body, logfile=logfile,
                          cfg=body if isinstance(body, dict) else None)
    except Exception:
        return False

