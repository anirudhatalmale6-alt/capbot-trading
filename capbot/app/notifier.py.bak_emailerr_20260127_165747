from __future__ import annotations
from typing import Any, Dict
import os
import socket
import smtplib
from email.message import EmailMessage

from capbot.notify.email_templates import render_email, subject as subject_tpl

def _send_smtp(subject: str, text_body: str, html_body: str) -> None:
    SMTP_HOST = os.getenv("SMTP_HOST")
    SMTP_PORT = int(os.getenv("SMTP_PORT", "587"))
    SMTP_USER = os.getenv("SMTP_USER")
    SMTP_PASS = os.getenv("SMTP_PASS")
    EMAIL_TO = os.getenv("EMAIL_TO")
    EMAIL_FROM = os.getenv("EMAIL_FROM", SMTP_USER or "")

    if not (SMTP_HOST and SMTP_USER and SMTP_PASS and EMAIL_TO and EMAIL_FROM):
        raise RuntimeError("Missing SMTP_* or EMAIL_* env vars")

    msg = EmailMessage()
    msg["From"] = EMAIL_FROM
    msg["To"] = EMAIL_TO
    msg["Subject"] = subject

    # multipart/alternative
    msg.set_content(text_body)
    msg.add_alternative(html_body, subtype="html")

    with smtplib.SMTP(SMTP_HOST, SMTP_PORT, timeout=20) as s:
        s.ehlo()
        try:
            s.starttls()
            s.ehlo()
        except Exception:
            pass
        s.login(SMTP_USER, SMTP_PASS)
        s.send_message(msg)

def email_event(enabled: bool, bot_id: str, event: str, data: Dict[str, Any], logfile) -> None:
    if not enabled:
        return

    # meta útil (sin “tonterías”)
    meta = {
        "host": socket.gethostname(),
        "service": os.getenv("CAPBOT_SERVICE", ""),  # opcional: puedes setearlo en systemd si quieres
        "tz_name": (os.getenv("TZ") or os.getenv("CAPBOT_TZ") or "Europe/Berlin"),
    }

    # Si tenemos logfile, mete última línea (queda pro)
    try:
        if logfile:
            meta["last_line"] = ""
            # si logfile es handle o path, intentamos sacarlo
            path = None
            if isinstance(logfile, str):
                path = logfile
            else:
                path = getattr(logfile, "name", None)
            if path:
                with open(path, "rb") as f:
                    f.seek(0, 2)
                    size = f.tell()
                    f.seek(max(0, size - 4096))
                    chunk = f.read().decode("utf-8", "ignore")
                lines = [l for l in chunk.splitlines() if l.strip()]
                meta["last_line"] = lines[-1] if lines else ""
    except Exception:
        pass

    # subject corto como pediste
    subj = subject_tpl(bot_id, event)

    text_body, html_body = render_email(event=event, bot_id=bot_id, payload=(data or {}), meta=meta)
    _send_smtp(subj, text_body, html_body)
