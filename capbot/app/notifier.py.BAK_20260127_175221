from __future__ import annotations

import os
import socket
import smtplib
import inspect
from typing import Dict, Any, Optional, Tuple
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from capbot.notify import email_templates as et


def _safe_get(d: Dict[str, Any], *keys, default=None):
    cur = d
    for k in keys:
        if not isinstance(cur, dict) or k not in cur:
            return default
        cur = cur[k]
    return cur


def _env(name: str, default: str = "") -> str:
    v = os.getenv(name)
    return default if v is None else str(v)


def _send_smtp(subj: str, text_body: str, html_body: str, cfg: Optional[Dict[str, Any]] = None) -> None:
    cfg = cfg or {}

    host = _env("SMTP_HOST") or _safe_get(cfg, "smtp", "host", default="")
    port = int(_env("SMTP_PORT") or _safe_get(cfg, "smtp", "port", default=587) or 587)
    user = _env("SMTP_USER") or _safe_get(cfg, "smtp", "user", default="")
    pwd  = _env("SMTP_PASS") or _safe_get(cfg, "smtp", "pass", default="")
    mail_to   = _env("EMAIL_TO") or _safe_get(cfg, "email", "to", default="")
    mail_from = _env("EMAIL_FROM") or _safe_get(cfg, "email", "from", default=user or mail_to)

    if not host or not mail_to:
        raise RuntimeError("SMTP_HOST / EMAIL_TO missing")

    msg = MIMEMultipart("alternative")
    msg["Subject"] = subj
    msg["From"] = mail_from
    msg["To"] = mail_to

    msg.attach(MIMEText(text_body or "", "plain", "utf-8"))
    msg.attach(MIMEText(html_body or "", "html", "utf-8"))

    with smtplib.SMTP(host, port, timeout=20) as s:
        s.ehlo()
        try:
            s.starttls()
            s.ehlo()
        except Exception:
            pass
        if user and pwd:
            s.login(user, pwd)
        s.sendmail(mail_from, [mail_to], msg.as_string())


def _render_email_compat(event: str, bot_id: str, payload: Dict[str, Any], meta: Dict[str, Any]) -> Tuple[str, str, str]:
    """
    Devuelve (subject, text, html), compatible con distintas firmas de email_templates.
    """
    # Subject: si existe et.subject úsalo; si no, algo simple
    subj = None
    if hasattr(et, "subject") and callable(getattr(et, "subject")):
        try:
            # intentamos varias combinaciones típicas
            try:
                subj = et.subject(event=event, bot=bot_id, market=payload.get("market") or payload.get("epic") or "")
            except TypeError:
                subj = et.subject(event, bot_id, payload.get("market") or payload.get("epic") or "")
        except Exception:
            subj = None
    if not subj:
        market_label = payload.get("market_label") or payload.get("market") or "Germany 40"
        tf = payload.get("timeframe") or payload.get("resolution") or "5m"
        subj = f"{market_label} {tf} | {event}"

    # Body: render_email con introspección de firma
    render = getattr(et, "render_email", None)
    if not callable(render):
        # fallback ultra simple
        txt = f"{subj}\n\n{payload}\n\n{meta}"
        html = f"<pre>{txt}</pre>"
        return subj, txt, html

    sig = inspect.signature(render)
    params = sig.parameters

    kwargs: Dict[str, Any] = {}
    if "event" in params:
        kwargs["event"] = event
    if "bot_id" in params:
        kwargs["bot_id"] = bot_id
    if "market" in params:
        kwargs["market"] = payload.get("market") or payload.get("market_label") or ""
    if "payload" in params:
        kwargs["payload"] = payload
    if "meta" in params:
        kwargs["meta"] = meta

    try:
        out = render(**kwargs) if kwargs else render(event, payload, meta)
    except TypeError:
        # intentos posicionales comunes
        try:
            out = render(event, payload, meta)
        except Exception:
            out = render(payload, meta)

    # out puede ser (text, html) o dict o str; normalizamos
    if isinstance(out, tuple) and len(out) == 2:
        text_body, html_body = out
    elif isinstance(out, str):
        text_body, html_body = out, f"<pre>{out}</pre>"
    else:
        text_body = str(out)
        html_body = f"<pre>{text_body}</pre>"

    return subj, text_body, html_body


def email_event(enabled: bool, bot_id: str, event: str, data: Dict[str, Any], logfile: str = "", cfg: Optional[Dict[str, Any]] = None) -> None:
    if not enabled:
        return
    cfg = cfg or {}

    host = socket.gethostname()
    service = cfg.get("service") or ""
    meta = {
        "bot_id": bot_id,
        "host": host,
        "service": service,
        "logfile": logfile or "",
    }

    try:
        subj, text_body, html_body = _render_email_compat(event=event, bot_id=bot_id, payload=(data or {}), meta=meta)
        _send_smtp(subj, text_body, html_body, cfg=cfg)
        print(f"EMAIL OK subject=[{subj}]")
    except Exception as e:
        try:
            print(f"EMAIL_ERR: {repr(e)}")
        except Exception:
            pass


def email_startup(enabled: bool, bot_id: str, cfg: dict, logfile: str = "") -> None:
    if not enabled:
        return
    data = {
        "event": "STARTED",
        "bot_id": bot_id,
        "market": (cfg.get("market") or cfg.get("symbol") or "GER40"),
        "market_label": (cfg.get("market_label") or "Germany 40"),
        "timeframe": (cfg.get("timeframe") or cfg.get("resolution") or "5m"),
        "strategy": ((cfg.get("strategy") or {}).get("module") or ""),
        "config_path": cfg.get("_config_path") or cfg.get("config_path") or "",
        "logfile": logfile or "",
    }
    email_event(True, bot_id, "STARTED", data, logfile=logfile, cfg=cfg)
