from __future__ import annotations

import os
import socket
import smtplib
from typing import Dict, Any, Optional, Tuple
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from capbot.notify.email_templates import subject as tmpl_subject, render_email as tmpl_render


def _safe_get(d: Dict[str, Any], *keys, default=None):
    cur = d
    for k in keys:
        if not isinstance(cur, dict) or k not in cur:
            return default
        cur = cur[k]
    return cur


def _env(name: str, default: str = "") -> str:
    v = os.getenv(name)
    return default if v is None else str(v)


def _send_smtp(subj: str, text_body: str, html_body: str, cfg: Optional[Dict[str, Any]] = None) -> None:
    cfg = cfg or {}
    host = _env("SMTP_HOST") or _safe_get(cfg, "smtp", "host", default="")
    port = int(_env("SMTP_PORT", "587") or _safe_get(cfg, "smtp", "port", default=587))
    user = _env("SMTP_USER") or _safe_get(cfg, "smtp", "user", default="")
    pw   = _env("SMTP_PASS") or _safe_get(cfg, "smtp", "pass", default="")
    to_  = _env("EMAIL_TO")  or _safe_get(cfg, "email", "to", default="")
    frm  = _env("EMAIL_FROM") or _safe_get(cfg, "email", "from", default=user)

    if not host or not to_ or not frm:
        raise RuntimeError(f"SMTP missing config (host/to/from). host={host!r} to={to_!r} from={frm!r}")

    msg = MIMEMultipart("alternative")
    msg["Subject"] = subj
    msg["From"] = frm
    msg["To"] = to_

    msg.attach(MIMEText(text_body or "", "plain", "utf-8"))
    msg.attach(MIMEText(html_body or "", "html", "utf-8"))

    with smtplib.SMTP(host, port, timeout=20) as s:
        s.ehlo()
        try:
            s.starttls()
            s.ehlo()
        except Exception:
            # si el server no soporta TLS, seguimos
            pass
        if user and pw:
            s.login(user, pw)
        s.sendmail(frm, [to_], msg.as_string())


def email_event(enabled: bool, bot_id: str, event: str, data: Dict[str, Any], logfile=None, cfg: Optional[Dict[str, Any]] = None) -> None:
    if not enabled:
        return

    cfg = cfg or {}
    market = str(data.get("market") or cfg.get("market") or cfg.get("symbol") or "GER40")
    tf = str(data.get("timeframe") or cfg.get("timeframe") or cfg.get("resolution") or "5m")

    meta = {
        "ts_utc": data.get("ts_utc") or data.get("ts") or "",
        "ts_local": data.get("ts_local") or "",
        "bot_id": bot_id,
        "service": data.get("service") or "",
        "host": socket.gethostname(),
        "config_path": data.get("config_path") or cfg.get("_config_path") or "",
        "logfile": data.get("logfile") or (str(logfile) if logfile else ""),
        "timeframe": tf,
        "market": market,
    }

    subj = f"{market} {tf}"
    # si quieres distinguir eventos en subject sin “tonterías”, añade solo lo mínimo:
    # subj = f"{market} {tf} | {event}"

    text_body, html_body = tmpl_render(event=event, market=market, payload=data or {}, meta=meta)

    try:
        _send_smtp(subj, text_body, html_body, cfg=cfg)
        print(f"[EMAIL OK] {subj}")
    except Exception as e:
        print(f"[EMAIL_ERR] {subj} -> {repr(e)}")


def email_startup(enabled: bool, bot_id: str, cfg: dict, logfile: str = "") -> None:
    if not enabled:
        return
    data = {
        "event": "STARTED",
        "bot_id": bot_id,
        "market": (cfg.get("market") or cfg.get("symbol") or "GER40"),
        "timeframe": (cfg.get("timeframe") or cfg.get("resolution") or "5m"),
        "strategy": ((cfg.get("strategy") or {}).get("module") or ""),
        "config_path": cfg.get("_config_path") or cfg.get("config_path") or "",
        "logfile": logfile or "",
    }
    email_event(True, bot_id, "STARTED", data, logfile=logfile, cfg=cfg)
