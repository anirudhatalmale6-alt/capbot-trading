from __future__ import annotations

from datetime import datetime, timezone
from html import escape
from typing import Any, Dict, Tuple, Optional


ICON = {
    "STARTED": "ğŸš€",
    "HEALTH": "âœ…",
    "ENTRY_OPENED": "ğŸŸ¢",
    "EXIT_TP": "ğŸ¯",
    "EXIT_SL": "ğŸ›‘",
    "EXIT_TIME": "â±ï¸",
    "EXIT_RTH": "ğŸŒ™",
    "TRAIL_SL": "ğŸ§·",
    "ERROR": "âš ï¸",
}

EVENT_TITLE = {
    "STARTED": "Started",
    "HEALTH": "Health",
    "ENTRY_OPENED": "Entry opened",
    "EXIT_TP": "Exit (TP)",
    "EXIT_SL": "Exit (SL)",
    "EXIT_TIME": "Exit (Time)",
    "EXIT_RTH": "Exit (RTH)",
    "TRAIL_SL": "Trail SL",
    "ERROR": "Error",
}


def _fmt(v: Any, nd: int = 2) -> str:
    try:
        if v is None:
            return "-"
        if isinstance(v, bool):
            return "âœ…" if v else "âŒ"
        if isinstance(v, (int, float)):
            return f"{float(v):.{nd}f}"
        return str(v)
    except Exception:
        return str(v)


def _safe_get(d: Any, *keys, default=None):
    cur = d
    for k in keys:
        if not isinstance(cur, dict) or k not in cur:
            return default
        cur = cur[k]
    return cur


def _norm_tf(v: Any) -> str:
    s = (str(v) if v is not None else "").strip()
    if not s:
        return "5m"
    # normalizaciones tÃ­picas
    if s.upper() in ("MINUTE_5", "M5", "5MIN", "5_MIN", "5M"):
        return "5m"
    if s.upper() in ("MINUTE_1", "M1", "1MIN", "1_MIN", "1M"):
        return "1m"
    return s.lower()


def _norm_market(v: Any) -> str:
    s = (str(v) if v is not None else "").strip()
    if not s:
        return "Germany40"
    u = s.upper()
    # normalizaciones tÃ­picas DE40/GER40
    if u in ("DE40", "GER40", "GERMANY40", "GERMANY 40"):
        return "Germany40"
    return s


def _event_icon(event: str) -> str:
    return ICON.get(event, "ğŸ“£")


def _event_title(event: str) -> str:
    return EVENT_TITLE.get(event, event)


def subject(event: str, market: str, timeframe: str) -> str:
    # Lo que pediste: simple y Ãºtil
    # (sin dicts, sin basura)
    m = _norm_market(market)
    tf = _norm_tf(timeframe)
    ev = _event_title(event).upper()
    return f"{m} {tf} | {ev}"


def _preview_line(event: str, market: str, timeframe: str) -> str:
    m = _norm_market(market)
    tf = _norm_tf(timeframe)
    return f"{m} {tf} â€” {_event_title(event)} {_event_icon(event)}"


def _html_card(headline: str, summary: str, rows_html: str, footer: str) -> str:
    return f"""<!doctype html>
<html>
  <body style="font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#f6f7fb;margin:0;padding:20px;">
    <div style="max-width:720px;margin:0 auto;background:#ffffff;border:1px solid #e6e8f0;border-radius:14px;overflow:hidden;">
      <div style="padding:18px 18px 10px 18px;border-bottom:1px solid #eef0f6;">
        <div style="font-size:18px;font-weight:700;margin:0 0 6px 0;color:#111827;">{headline}</div>
        <div style="font-size:13px;color:#4b5563;line-height:1.35;">{summary}</div>
      </div>
      <div style="padding:12px 18px 18px 18px;">
        <table style="width:100%;border-collapse:separate;border-spacing:0;">
          {rows_html}
        </table>
      </div>
      <div style="padding:12px 18px;background:#fafbff;border-top:1px solid #eef0f6;font-size:12px;color:#6b7280;">
        {footer}
      </div>
    </div>
  </body>
</html>"""


def _row(k: str, v: Any) -> str:
    return (
        "<tr>"
        f"<td style='padding:8px 10px;color:#6b7280;white-space:nowrap;border-bottom:1px solid #eef0f6;font-size:13px'>{escape(str(k))}</td>"
        f"<td style='padding:8px 10px;color:#111827;border-bottom:1px solid #eef0f6;font-size:13px'>{escape(str(v))}</td>"
        "</tr>"
    )


def render_email(*args, **kwargs) -> Tuple[str, str]:
    """
    Compat: soporta llamadas tipo:
      - render_email(event, payload, meta)
      - render_email(bot_id, event, payload, meta)
      - render_email(event=..., payload=..., meta=...)
    Devuelve: (text_body, html_body)
    """

    event = kwargs.get("event")
    payload = kwargs.get("payload")
    meta = kwargs.get("meta")

    if event is None and len(args) >= 1:
        event = args[0]
    if payload is None and len(args) >= 2:
        payload = args[1]
    if meta is None and len(args) >= 3:
        meta = args[2]

    # Si venÃ­a (bot_id, event, payload, meta)
    if isinstance(event, str) and isinstance(payload, str) and isinstance(meta, dict) and len(args) >= 4:
        # event aquÃ­ era bot_id; corrige
        event = args[1]
        payload = args[2]
        meta = args[3]

    if not isinstance(payload, dict):
        payload = {"payload": payload}

    if not isinstance(meta, dict):
        meta = {"meta": meta}

    event = str(event or "EVENT")
    mkt = _safe_get(payload, "market", default=None) or _safe_get(payload, "epic", default=None) or _safe_get(meta, "market", default=None)
    tf  = _safe_get(payload, "timeframe", default=None) or _safe_get(payload, "resolution", default=None) or _safe_get(meta, "timeframe", default=None)

    market = _norm_market(mkt)
    timeframe = _norm_tf(tf)

    # --- TEXT (preview limpio) ---
    lines = []
    lines.append(_preview_line(event, market, timeframe))
    lines.append("")  # <- esto hace que Gmail preview sea SOLO la primera lÃ­nea limpia

    # AÃ±ade info, pero sin dicts crudos
    # (si hay dict/list, lo compactamos o lo saltamos)
    key_order = [
        ("Bot", _safe_get(payload, "bot_id", default=_safe_get(meta, "bot_id", default=""))),
        ("Time (UTC)", _safe_get(meta, "ts_utc", default=_safe_get(payload, "ts_utc", default=""))),
        ("Time (Local)", _safe_get(meta, "ts_local", default=_safe_get(payload, "ts_local", default=""))),
        ("Host", _safe_get(meta, "host", default="")),
        ("Service", _safe_get(meta, "service", default="")),
        ("State", _safe_get(payload, "state", default=_safe_get(meta, "state", default=""))),
        ("Log age (min)", _safe_get(payload, "log_age_min", default=_safe_get(meta, "log_age_min", default=""))),
        ("Last", _safe_get(payload, "last", default=_safe_get(meta, "last", default=""))),
    ]

    for k, v in key_order:
        if v is None or v == "":
            continue
        if isinstance(v, (dict, list, tuple)):
            continue
        lines.append(f"{k}: {v}")

    text_body = "\n".join(lines).strip() + "\n"

    # --- HTML (caja bonita) ---
    headline = f"{_event_icon(event)} {market} {timeframe} â€” {_event_title(event)}"
    summary = escape(_preview_line(event, market, timeframe))

    rows = []
    # mostramos payload/meta sin mierda
    # payload â€œcoreâ€
    core = {
        "Bot": _safe_get(payload, "bot_id", default=_safe_get(meta, "bot_id", default="")),
        "Market": market,
        "Timeframe": timeframe,
        "UTC / Local": f"{_safe_get(meta,'ts_utc',default='')} / {_safe_get(meta,'ts_local',default='')}",
        "Host / Service": f"{_safe_get(meta,'host',default='')} / {_safe_get(meta,'service',default='')}",
        "State": _safe_get(payload, "state", default=_safe_get(meta, "state", default="")),
        "Log age (min)": _safe_get(payload, "log_age_min", default=_safe_get(meta, "log_age_min", default="")),
        "Last": _safe_get(payload, "last", default=_safe_get(meta, "last", default="")),
    }

    for k, v in core.items():
        if v is None or v == "" or v == " / ":
            continue
        rows.append(_row(k, v))

    footer = escape(str(_safe_get(meta, "footer", default="")))

    html_body = _html_card(headline, summary, "\n".join(rows), footer)

    return text_body, html_body
